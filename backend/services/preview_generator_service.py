{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/B0ss-M/Live2MPC/blob/main/backend/services/preview_generator_service.py\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import os\n",
        "import xml.etree.ElementTree as ET\n",
        "from pydub import AudioSegment\n",
        "from typing import List, Tuple\n",
        "\n",
        "class PreviewGeneratorService:\n",
        "    \"\"\"\n",
        "    A service to generate audio previews for MPC programs.\n",
        "    \"\"\"\n",
        "\n",
        "    def _get_samples_from_xpm(self, xpm_path: str, samples_directory: str) -> List[Tuple[int, str]]:\n",
        "        \"\"\"\n",
        "        Parses an XPM file to extract sample filenames and their root MIDI notes.\n",
        "        \"\"\"\n",
        "        samples = []\n",
        "        try:\n",
        "            tree = ET.parse(xpm_path)\n",
        "            root = tree.getroot()\n",
        "\n",
        "            # Find all layers and their corresponding sample file and MIDI note\n",
        "            for layer in root.findall('.//{http://www.akaipro.com/xpm}Layer'):\n",
        "                sample_file_element = layer.find('{http://www.akaipro.com/xpm}sampleFileName')\n",
        "                root_note_element = layer.find('{http://www.akaipro.com/xpm}rootNote')\n",
        "\n",
        "                if sample_file_element is not None and sample_file_element.text and root_note_element is not None:\n",
        "                    sample_filename = os.path.basename(sample_file_element.text)\n",
        "                    sample_path = os.path.join(samples_directory, sample_filename)\n",
        "                    if os.path.exists(sample_path):\n",
        "                        samples.append((int(root_note_element.text), sample_path))\n",
        "\n",
        "            # Sort samples by root note\n",
        "            samples.sort()\n",
        "            return samples\n",
        "\n",
        "        except ET.ParseError as e:\n",
        "            print(f\"Error parsing XPM file for preview generation: {e}\")\n",
        "            return []\n",
        "        except Exception as e:\n",
        "            print(f\"An unexpected error occurred while parsing XPM for preview: {e}\")\n",
        "            return []\n",
        "\n",
        "    def generate_preview(self, xpm_path: str, samples_directory: str, output_path: str) -> bool:\n",
        "        \"\"\"\n",
        "        Generates a simple audio preview by sequencing the first few samples from an XPM.\n",
        "\n",
        "        Args:\n",
        "            xpm_path: The path to the .xpm program file.\n",
        "            samples_directory: The directory containing the referenced samples.\n",
        "            output_path: The path to save the generated preview file (e.g., preview.wav).\n",
        "\n",
        "        Returns:\n",
        "            True if the preview was generated successfully, False otherwise.\n",
        "        \"\"\"\n",
        "        program_samples = self._get_samples_from_xpm(xpm_path, samples_directory)\n",
        "\n",
        "        if not program_samples:\n",
        "            print(\"No valid samples found in the XPM to generate a preview.\")\n",
        "            return False\n",
        "\n",
        "        # Use the first 4 samples for the preview, or fewer if not available\n",
        "        samples_to_sequence = program_samples[:4]\n",
        "\n",
        "        # Define the duration of each step in milliseconds\n",
        "        step_duration_ms = 500\n",
        "        preview_duration_ms = len(samples_to_sequence) * step_duration_ms\n",
        "\n",
        "        # Create a silent base for the preview\n",
        "        preview = AudioSegment.silent(duration=preview_duration_ms)\n",
        "\n",
        "        for i, (_, sample_path) in enumerate(samples_to_sequence):\n",
        "            try:\n",
        "                # Load the sample audio\n",
        "                sample_audio = AudioSegment.from_file(sample_path)\n",
        "\n",
        "                # Overlay the sample at its designated time slot\n",
        "                position = i * step_duration_ms\n",
        "                preview = preview.overlay(sample_audio, position=position)\n",
        "            except Exception as e:\n",
        "                print(f\"Could not load or process sample '{sample_path}': {e}\")\n",
        "                continue # Skip this sample and move to the next\n",
        "\n",
        "        if preview.duration_seconds > 0:\n",
        "            # Export the final preview file\n",
        "            preview.export(output_path, format=\"wav\")\n",
        "            return True\n",
        "        else:\n",
        "            print(\"Preview generation resulted in an empty audio file.\")\n",
        "            return False"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "id": "-WdHgU0CDUoO"
      }
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}